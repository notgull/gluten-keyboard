// MIT/Apaache2 License

use std::{
    env,
    fs::File,
    io::{prelude::*, BufReader, BufWriter},
    iter,
};

struct Key {
    name: String,
    value: Option<char>,
}

#[inline]
fn read_keys<T: Read>(reader: &mut T) -> impl Iterator<Item = Key> + '_ {
    // iterate over lines
    struct LineIterator<'a, T> {
        reader: &'a mut T,
    }

    impl<'a, T: Read> Iterator for LineIterator<'a, T> {
        type Item = String;

        #[inline]
        fn next(&mut self) -> Option<String> {
            let mut buffer: Vec<u8> = Vec::with_capacity(20);

            loop {
                let mut byte = 0;

                if self
                    .reader
                    .read_exact(ref_slice::ref_slice_mut(&mut byte))
                    .is_err()
                {
                    return None;
                }
                match byte {
                    b'\n' => break,
                    0 => return None,
                    byte => {
                        buffer.push(byte);
                    }
                }
            }

            String::from_utf8(buffer).ok()
        }
    }

    LineIterator { reader }
        .filter(|line| {
            !line.is_empty()
                && line.chars().nth(0) != Some('#')
                && line.chars().any(|i| i != ' ' && i != '\n')
        })
        .map(|line| {
            let oline = line.split('#').next().unwrap_or_else(|| "");
            let mut splitter = oline.split(' ');
            let p1 = splitter.next().unwrap();
            let p2 = splitter.next();

            Key {
                name: p1.to_string(),
                value: p2
                    .as_ref()
                    .and_then(|p2| u32::from_str_radix(&p2, 16).ok())
                    .and_then(|p2| std::char::from_u32(p2)),
            }
        })
}

#[inline]
fn process_keys<T: Write>(writer: &mut T, keys: impl Iterator<Item = Key>) {
    let mut enum_pool = "
// Generated by gluten-keyboard-generator, and is dual licensed under the MIT and Apache2 Licenses

#![no_std]

//! Provides an enum containing keys found on most keyboards. Useful for implementing a system where the user
//! needs to handle keyboard input. Made because I couldn't find a useful standard that didn't pretend everything
//! used `char`.

/// A set of keys.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Key {
    ".to_string();
    let mut streq_pool = "
}

impl Default for Key {
    #[inline]
    fn default() -> Self {
        Self::Unknown
    }
}

impl Key {
    #[inline]
    pub fn as_char(self) -> Option<char> {
        match self {
"
    .to_string();
    const ENDING: &str = "
            _ => None,
        }
    }
}";

    keys.for_each(|key| {
        enum_pool.extend(iter::once(format!(
            "
    /// The {}{} key.
    {},",
            &key.name,
            match key.value {
                None => "".to_string(),
                Some(value) => format!(" ({})", value),
            },
            &key.name,
        )));

        if let Some(value) = key.value {
            streq_pool.extend(iter::once(format!(
                "
                        Key::{} => Some('\\u{{{:x}}}'),",
                &key.name, value as u32,
            )));
        }
    });

    writer.write_all(enum_pool.as_bytes()).unwrap();
    writer.write_all(streq_pool.as_bytes()).unwrap();
    writer.write_all(ENDING.as_bytes()).unwrap();
}

fn main() {
    let mut args = env::args_os().skip(1);
    let mut input = BufReader::new(File::open(args.next().unwrap()).unwrap());
    let mut output = BufWriter::new(File::create(args.next().unwrap()).unwrap());
    process_keys(&mut output, read_keys(&mut input));
}
